# -*- coding: utf-8 -*-
"""Projeto_visualização.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f12rdO1deH4S2LB95RWV5ponuG15Oor5
"""

from google.colab import drive
import sys
drive.mount("/content/drive", force_remount=True)
root  = '/content/drive/My Drive/projeto'
sys.path.append(root)

!pip install skater

!pip install interpret

import skater
import interpret
import numpy as np
import pandas as pd
import seaborn as sns
import itertools
import matplotlib.pyplot as plt
from sklearn.datasets import make_classification
from sklearn import model_selection
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn import metrics

# Classifiers
from sklearn.svm import NuSVC, SVC
from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import RandomForestClassifier
#from mlxtend.classifier import StackingCVClassifier # <- Here is our boy

# Used to ignore warnings generated from StackingCVClassifier
import warnings
warnings.simplefilter('ignore')

from sklearn.model_selection import train_test_split
import random
import numpy as np
import pandas
random.seed(1)
# importar a base e colocar os nomes das colunas
overallstr = pandas.read_csv('/content/drive/My Drive/overallprocessed.csv',sep = ',')

# Commented out IPython magic to ensure Python compatibility.
from __future__ import print_function
# Remoção de outliers
from scipy.stats import zscore
z_scores = zscore(overallstr)
abs_z_scores = np.abs(z_scores)
filtered_entries = (abs_z_scores < 3).all(axis=1)
#print(filtered_entries)
new_overall = overallstr[filtered_entries]
overallstr = pandas.DataFrame(new_overall)

# %matplotlib inline
import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
plt.style.use('ggplot')
# Reference for customizing plots : http://matplotlib.org/users/customizing.html
# print(plt.style.available)

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

data = overallstr
data.Situação.value_counts().plot(kind='bar', title='Count (target)');
df_class_0 = data[data['Situação'] == 0]
df_class_1 = data[data['Situação'] == 1]
count_class_1, count_class_0 = data.Situação.value_counts()
df_class_0_over = df_class_0.sample(count_class_1, replace=True)
df_test_over = pd.concat([df_class_1, df_class_0_over], axis=0)

print('Random over-sampling:')
print(df_test_over.Situação.value_counts())

df_test_over.Situação.value_counts().plot(kind='bar', title='Count (target)');
X = pd.DataFrame(df_test_over, columns=data.columns)
X = X.drop(['Situação','ID','FilmProcessed','FilmInSpec','Weight', 'Unnamed: 0'], axis = 1)
y = df_test_over.Situação
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = .2, stratify = y)
print("Classes {}".format(np.unique(y)))
print(X.describe)

from sklearn.metrics import f1_score,accuracy_score
from sklearn.metrics import matthews_corrcoef
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from random import seed

seed(3)

models = {'gb':GradientBoostingClassifier(), 
          'mlp':MLPClassifier(hidden_layer_sizes=(100,20)), 
          'knn':KNeighborsClassifier(n_neighbors= 3), 
          'reg':LogisticRegression()}
f1 = {}
acuracia = {}
matthews = {}
results = pd.DataFrame()
for model_key in models:
    model = models[model_key]
    model.fit(X_train, y_train)
    preds = model.predict(X_test)
    f1[model_key] = f1_score(y_test, preds)
    acuracia[model_key] = accuracy_score(y_test, preds)
    matthews[model_key] = matthews_corrcoef(y_test,preds)
    y_pred = models[model_key].predict_proba(X_test)[:,1]
    if f1[model_key] < 0 :
      f1[model_key] = 0
    if acuracia[model_key] < 0 :
      acuracia[model_key] = 0
    if matthews[model_key] < 0 :
      matthews[model_key] = 0
    # Save results in pandas dataframe object
    results[f"{model_key}"] = y_pred

results['Situacao'] = y_test.values
print("F1 for {0}: {1}".format(model_key, f1))
print("Acurácia for {0}: {1}".format(model_key, acuracia))
print("Matthews correlation coef for {0}: {1}".format(model_key, matthews))

sns.set(font_scale = 1)
sns.set_style({"axes.facecolor": "1.0", "axes.edgecolor": "0.85", "grid.color": "0.85",
               "grid.linestyle": "-", 'axes.labelcolor': '0.4', "xtick.color": "0.4",
               'ytick.color': '0.4'})

AUC = {}
# Plot
def probabilities_plot():
  f, ax = plt.subplots(figsize=(10, 4), nrows=1, ncols = 4)
  for key, counter in zip(models, range(4)):
      # Get predictions
      y_pred = results[key]
      
      # Get AUC
      auc = metrics.roc_auc_score(y_test, y_pred)
      textstr = f"AUC: {auc:.3f}"
      AUC[key] = auc

      # Plot false distribution
      false_pred = results[results['Situacao'] == 0]
      sns.distplot(false_pred[key], hist=True, kde=False, 
                  bins=int(25), color = 'blue',
                  hist_kws={'edgecolor':'black'}, ax = ax[counter])
      
      # Plot true distribution
      true_pred = results[results['Situacao'] == 1]
      sns.distplot(results[key], hist=True, kde=False, 
                  bins=int(25), color = 'green',
                  hist_kws={'edgecolor':'black'}, ax = ax[counter])
      
      
      # These are matplotlib.patch.Patch properties
      props = dict(boxstyle='round', facecolor='white', alpha=0.5)
      
      # Place a text box in upper left in axes coords
      ax[counter].text(0.05, 0.95, textstr, transform=ax[counter].transAxes, fontsize=14,
                      verticalalignment = "top", bbox=props)
      
      # Set axis limits and labels
      ax[counter].set_title(f"{key} Distribution")
      ax[counter].set_xlim(0,1)
      ax[counter].set_xlabel("Probability")
  return
  # Tight layout
  plt.tight_layout()
probabilities_plot()
# Save Figure
plt.savefig("Probability Distribution for each Classifier.png", dpi = 1080)

# Libraries
import matplotlib.pyplot as plt
import pandas as pd
from math import pi
 
# Set data
df = pd.DataFrame({
'group': ['XGB','MLP','KNN','REG'],
'F1': [f1['gb'], f1['mlp'], f1['knn'], f1['reg']],
'Acurácia': [acuracia['gb'], acuracia['mlp'], acuracia['knn'], acuracia['reg']],
'MCC': [matthews['gb'], matthews['mlp'], matthews['knn'], matthews['reg']],
'AUC': [AUC['gb'], AUC['mlp'], AUC['knn'], AUC['reg']]
})
 
 
 
# ------- PART 1: Create background
def plot_performance(): 
  # number of variable
  categories=list(df)[1:]
  N = len(categories)
  
  # What will be the angle of each axis in the plot? (we divide the plot / number of variable)
  angles = [n / float(N) * 2 * pi for n in range(N)]
  angles += angles[:1]
  
  # Initialise the spider plot
  ax = plt.subplot(111, polar=True)
  
  # If you want the first axis to be on top:
  ax.set_theta_offset(pi / 2)
  ax.set_theta_direction(-1)
  
  # Draw one axe per variable + add labels labels yet
  plt.xticks(angles[:-1], categories)
  
  # Draw ylabels
  ax.set_rlabel_position(0)
  plt.yticks([0.25,0.50,0.75,1.0], ["0.25","0.50","0.75", "1.0"], color="black", size=10)
  plt.ylim(0,1)
  
  
  # ------- PART 2: Add plots
  
  # Plot each individual = each line of the data
  # I don't do a loop, because plotting more than 3 groups makes the chart unreadable
  
  # Ind1
  values=df.loc[0].drop('group').values.flatten().tolist()
  values += values[:1]
  ax.plot(angles, values, linewidth=2, linestyle='solid', label="XGB")
  ax.fill(angles, values, 'b', alpha=0.1)
  
  # Ind2
  values=df.loc[1].drop('group').values.flatten().tolist()
  values += values[:1]
  ax.plot(angles, values, linewidth=2, linestyle='solid', label="MLP")
  ax.fill(angles, values, 'r', alpha=0.2)

  # Ind3
  values=df.loc[2].drop('group').values.flatten().tolist()
  values += values[:1]
  ax.plot(angles, values, linewidth=2, linestyle='solid', label="KNN")
  ax.fill(angles, values, 'g', alpha=0.3)

  # Ind4
  values=df.loc[3].drop('group').values.flatten().tolist()
  values += values[:1]
  ax.plot(angles, values, linewidth=2, linestyle='solid', label="REG")
  ax.fill(angles, values, 'r', alpha=0.6)
  
  # Add legend
  plt.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import skater
from skater.core.explanations import Interpretation
from skater.model import InMemoryModel
from skater.core.local_interpretation.lime.lime_tabular import LimeTabularExplainer

"""
ax_dict = {
    'mlp':axes[0][0],
    'knn':axes[1][0],
    'reg':axes[0][1],
    'gb':axes[1][1]
}

interpreter = Interpretation(X, feature_names=X.columns)

f, axes = plt.subplots(2,2, figsize = (16, 16))
for model_key in models:
    pyint_model = InMemoryModel(models[model_key].predict_proba, examples=X_train)
    ax = ax_dict[model_key]
    interpreter.feature_importance.plot_feature_importance(pyint_model, ax=ax, ascending = True)
    ax.set_title(model_key)"""

import shap
shap.initjs()
explainer = shap.TreeExplainer(models['gb'])
shap_values = explainer.shap_values(X)
shap.force_plot(explainer.expected_value, shap_values[0,:], X.iloc[0,:])

import plotly.express as px
import param
import panel as pn
import json

class RatingsDashboard(param.Parameterized):
  def probabilites_plot(self):
    plt.close()
    return pn.pane.Matplotlib(probabilities_plot())

  def performance_plot(self):
    ax = plot_performance()
    plt.close()
    return ax

  def dispersion_plot(self):
    plt.close()
    return shap.summary_plot(shap_values,X)

  def predictions_plot(self):
    ax =  shap.force_plot(explainer.expected_value, shap_values, X)
    plt.close()
    return ax
  
  def parallel_plot(self):
    ax = px.parallel_coordinates(X, color = X['Media D.O.'], dimensions = ['ChillDown','CoatingTime','RewSetTension','WarmupTime','Boatlife'])
    plt.close()
    return ax
                          
  def example_explainer(self,value):
    exp = LimeTabularExplainer(X_train.values, 
                           feature_names=X.columns, 
                           discretize_continuous=True, 
                           class_names=['Reprovado', 'Aprovado'])
    plt.close()
    return exp.explain_instance(X_train.iloc[value].values, models['gb'].predict_proba).show_in_notebook()

rd = RatingsDashboard()

pn.extension()
gspec = pn.GridSpec(width= 1000, height=800)

gspec[0,:] = pn.Row(pn.Column(rd.performance_plot,pn.Column(rd.probabilites_plot)))

gspec

import holoviews as hv
import holoviews.plotting.bokeh

from bokeh.plotting import figure
pn.extension()
gspec_1 = pn.GridSpec(width= 1100, height= 500)
gspec_1[0,:] = pn.Row(pn.Pane(rd.dispersion_plot),sizing_mode='fixed') 
gspec_1

import holoviews as hv
import holoviews.plotting.bokeh

from bokeh.plotting import figure

pn.extension()
shap.initjs()
gspec_2 = pn.GridSpec(width = 1200,height= 800)
#gspec_1[0,:] = pn.Row(pn.Column(plot_performance()),pn.Column(probabilities_plot()))
gspec_2[0,:] = pn.Row(pn.Pane(rd.predictions_plot,width=1100),sizing_mode='fixed')
#gspec_1[3,0:1] = pn.Row(pn.Pane(rd.dispersion_plot, width = 600),sizing_mode='fixed') 
gspec_2[1,:] = pn.Row(pn.Pane(rd.parallel_plot, width = 1200),sizing_mode='fixed')
#gspec_1[0,:] = pn.Row(pn.Pane(rd.example_explainer,width=600),sizing_mode='fixed', )

gspec_2

import holoviews as hv
import holoviews.plotting.bokeh

from bokeh.plotting import figure
pn.extension()
#gspec_3 = pn.GridSpec(width = 1200,height= 800)
value = 2
gspec_3 = pn.Row(pn.Pane(rd.example_explainer(int(value)),width=600))
gspec_3

import holoviews as hv
import holoviews.plotting.bokeh

from bokeh.plotting import figure

pn.extension()
shap.initjs()
gspec_3 = pn.GridSpec(width = 1200,height= 800)
#gspec_1[0,:] = pn.Row(pn.Column(plot_performance()),pn.Column(probabilities_plot()))
gspec_3[-1,:] = pn.Row(pn.Pane(rd.dispersion_plot,width=1100),sizing_mode='fixed')
#gspec_1[3,0:1] = pn.Row(pn.Pane(rd.dispersion_plot, width = 600),sizing_mode='fixed') 
#gspec_3[1,:] = pn.Row(pn.Pane(rd.parallel_plot, width = 1200),sizing_mode='fixed')
#gspec_1[0,:] = pn.Row(pn.Pane(rd.example_explainer,width=600),sizing_mode='fixed', )

gspec_3

from bokeh.plotting import figure
pn.extension()
shap.initjs()
tabs = pn.Tabs(rd.predictions_plot)
tabs.append(rd.parallel_plot)
tabs.append(pn.Pane(plot_performance()))
tabs

